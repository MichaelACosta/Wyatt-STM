<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Wyatt-STM: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wyatt-STM
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Software transactional memory system developed at Wyatt Technology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">

<p>The core of the transactional memory system.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__versioning"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__versioning.html">Library Versioning</a></td></tr>
<tr class="memdesc:group__versioning"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the library version. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__profiling"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__profiling.html">Profiling</a></td></tr>
<tr class="memdesc:group__profiling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiling use of the library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__atomically__options"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__atomically__options.html">Options For Atomically</a></td></tr>
<tr class="memdesc:group__atomically__options"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the types that can be passed to Atomically as extra arguments in order to set transaction options. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_library_version.html">WSTM::WLibraryVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the library version.  <a href="struct_w_s_t_m_1_1_w_library_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_conflict_resolution.html">WSTM::WConflictResolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that tells Atomically how to react when it reaches it's conflict limit.  <a href="struct_w_s_t_m_1_1_w_conflict_resolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_time_arg.html">WSTM::WTimeArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time value that can be initialized using either a std::chrono::time_point or a std::chrono::duration.  <a href="struct_w_s_t_m_1_1_w_time_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_read_lock_guard.html">WSTM::WReadLockGuard&lt; ReadLockable_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-lock manager for <a class="el" href="class_w_s_t_m_1_1_w_atomic.html" title="Functions passed to Atomically must take a reference to one of these objects as their only argument...">WAtomic</a> and <a class="el" href="class_w_s_t_m_1_1_w_inconsistent.html" title="Functions passed to Inconsistently must take a reference to one of these objects as their only argume...">WInconsistent</a>.  <a href="class_w_s_t_m_1_1_w_read_lock_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_max_conflicts.html">WSTM::WMaxConflicts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the the maximum number of times that the operation should be re-run due to <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> changes by other threads before "conflict resolution" is used.  <a href="struct_w_s_t_m_1_1_w_max_conflicts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html">WSTM::WAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions passed to Atomically must take a reference to one of these objects as their only argument.  <a href="class_w_s_t_m_1_1_w_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_inconsistent.html">WSTM::WInconsistent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions passed to Inconsistently must take a reference to one of these objects as their only argument.  <a href="class_w_s_t_m_1_1_w_inconsistent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_exception.html">WSTM::WException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions thrown by <a class="el" href="namespace_w_s_t_m.html" title="The main namespace of the transactional memory system. ">WSTM</a> functions.  <a href="struct_w_s_t_m_1_1_w_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_cant_continue_exception.html">WSTM::WCantContinueException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for exceptions thrown by Atomically.  <a href="struct_w_s_t_m_1_1_w_cant_continue_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_max_retries_exception.html">WSTM::WMaxRetriesException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when STM::atomically hits it's retry limit.  <a href="struct_w_s_t_m_1_1_w_max_retries_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_max_conflicts_exception.html">WSTM::WMaxConflictsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when STM::atomically hits it's conflict limit.  <a href="struct_w_s_t_m_1_1_w_max_conflicts_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_retry_timeout_exception.html">WSTM::WRetryTimeoutException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a retry times out.  <a href="struct_w_s_t_m_1_1_w_retry_timeout_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_in_atomic_error.html">WSTM::WInAtomicError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by <a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html" title="Functions that cannot be called from within a transaction should take one of these as an argument...">WNoAtomic</a> if it is constructed within a transaction.  <a href="struct_w_s_t_m_1_1_w_in_atomic_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions that cannot be called from within a transaction should take one of these as an argument, with a default constructed object as the default value.  <a href="struct_w_s_t_m_1_1_w_no_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_var.html">WSTM::WVar&lt; Type_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transactional variable.  <a href="class_w_s_t_m_1_1_w_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_transaction_local_value.html">WSTM::WTransactionLocalValue&lt; Type_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable that has values "local" to a given transaction, sort of like a thread_local variable but for transactions instead of threads.  <a href="class_w_s_t_m_1_1_w_transaction_local_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_transaction_local_flag.html">WSTM::WTransactionLocalFlag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transaction local flag.  <a href="class_w_s_t_m_1_1_w_transaction_local_flag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9221933830131a2a911836b17028ab05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#ga9221933830131a2a911836b17028ab05">NO_ATOMIC</a>&#160;&#160;&#160;const ::<a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a>&amp; = ::<a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a>()</td></tr>
<tr class="memdesc:ga9221933830131a2a911836b17028ab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this as an argument in the declaration of functions that cannot be called from within a transaction.  <a href="#ga9221933830131a2a911836b17028ab05">More...</a><br /></td></tr>
<tr class="separator:ga9221933830131a2a911836b17028ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5797f24e23386e88e54c5269198cf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa5797f24e23386e88e54c5269198cf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#gaaa5797f24e23386e88e54c5269198cf7">NO_ATOMIC_IMPL</a>&#160;&#160;&#160;const ::<a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a>&amp;</td></tr>
<tr class="memdesc:gaaa5797f24e23386e88e54c5269198cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If NO_ATOMIC is used in a function's declaration this macro should be used for that argument in the function's definition. <br /></td></tr>
<tr class="separator:gaaa5797f24e23386e88e54c5269198cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga79f61cd02ad11aea2a826075c1f44500"><td class="memTemplParams" colspan="2">template&lt;typename Func_t , typename... Options_t&gt; </td></tr>
<tr class="memitem:ga79f61cd02ad11aea2a826075c1f44500"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___core.html#ga79f61cd02ad11aea2a826075c1f44500">WSTM::RunAtomically</a> (const Func_t &amp;f, const Options_t &amp;...options)</td></tr>
<tr class="memdesc:ga79f61cd02ad11aea2a826075c1f44500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a function object that runs the given function in a transaction with the given options.  <a href="group___core.html#ga79f61cd02ad11aea2a826075c1f44500">More...</a><br /></td></tr>
<tr class="separator:ga79f61cd02ad11aea2a826075c1f44500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3d5a4b1ddda4938ab30473b12c9502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd3d5a4b1ddda4938ab30473b12c9502"></a>
WSTM_LIBAPI bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#gafd3d5a4b1ddda4938ab30473b12c9502">WSTM::InAtomic</a> ()</td></tr>
<tr class="memdesc:gafd3d5a4b1ddda4938ab30473b12c9502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current thread is running under Atomically. <br /></td></tr>
<tr class="separator:gafd3d5a4b1ddda4938ab30473b12c9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac553425cfd41fcf60669313f91a162a3"><td class="memItemLeft" align="right" valign="top">WSTM_LIBAPI void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#gac553425cfd41fcf60669313f91a162a3">WSTM::Retry</a> (WAtomic &amp;at, const WTimeArg &amp;timeout=WTimeArg::Unlimited())</td></tr>
<tr class="memdesc:gac553425cfd41fcf60669313f91a162a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a function passed to Atomically determines that one of the <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> objects's that it has read has a value that prevents the function from finishing then the function should call Retry.  <a href="group___core.html#gac553425cfd41fcf60669313f91a162a3">More...</a><br /></td></tr>
<tr class="separator:gac553425cfd41fcf60669313f91a162a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7d014c3ea9b69abfa94e3ea7090da36e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d014c3ea9b69abfa94e3ea7090da36e"></a>
WSTM_LIBAPI const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___core.html#ga7d014c3ea9b69abfa94e3ea7090da36e">WSTM::UNLIMITED</a></td></tr>
<tr class="memdesc:ga7d014c3ea9b69abfa94e3ea7090da36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that denotes an unlimited number of tries. <br /></td></tr>
<tr class="separator:ga7d014c3ea9b69abfa94e3ea7090da36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf006fb968a6a4dae938779df0172295"><td class="memTemplParams" colspan="2">template&lt;typename Op_t &gt; </td></tr>
<tr class="memitem:gabf006fb968a6a4dae938779df0172295"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___core.html#gabf006fb968a6a4dae938779df0172295">WSTM::Inconsistently</a> (const Op_t &amp;op, <a class="el" href="group___core.html#ga9221933830131a2a911836b17028ab05">NO_ATOMIC</a>) -&gt; typename std::enable_if&lt; std::is_same&lt; void, decltype(op(std::declval&lt; WInconsistent &amp; &gt;()))&gt;::value, void &gt;::type    </td></tr>
<tr class="memdesc:gabf006fb968a6a4dae938779df0172295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the given function in an "inconsistent" transaction.  <a href="group___core.html#gabf006fb968a6a4dae938779df0172295">More...</a><br /></td></tr>
<tr class="separator:gabf006fb968a6a4dae938779df0172295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The core of the transactional memory system. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9221933830131a2a911836b17028ab05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_ATOMIC&#160;&#160;&#160;const ::<a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a>&amp; = ::<a class="el" href="struct_w_s_t_m_1_1_w_no_atomic.html">WSTM::WNoAtomic</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this as an argument in the declaration of functions that cannot be called from within a transaction. </p>
<p>If the function is called in a transaction an InAtomicError will be thrown. </p>

<p>Definition at line <a class="el" href="stm_8h_source.html#l00946">946</a> of file <a class="el" href="stm_8h_source.html">stm.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabf006fb968a6a4dae938779df0172295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WSTM::Inconsistently </td>
          <td>(</td>
          <td class="paramtype">const Op_t &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___core.html#ga9221933830131a2a911836b17028ab05">NO_ATOMIC</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;std::is_same&lt;void, decltype (op (std::declval&lt;<a class="el" href="class_w_s_t_m_1_1_w_inconsistent.html">WInconsistent</a>&amp;&gt;()))&gt;::value, void&gt;::type
   </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the given function in an "inconsistent" transaction. </p>
<p>This transaction is not committable and you cannot set <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> values when using this type of transaction. Also the value read from a <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> is not saved in the transaction so multiple reads from the same <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> in one of these transactions can yield different values. Note that reading the <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> values is still thread-safe, just not guaranteed consistent if the same <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> is read multiple times. This transaction also does not support Retry, and since it does not commit it will not be re-run if read <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a>'s change. Call this function if you are already operating under an atomic transaction will result in a run-time error. You can call Atomically from a function running under an inconsistent transaction, the atomic transaction will commit when the call to Atomically returns though. This type of transaction should only be used when a bunch of variables need to be read and it doesn't matter that they can change while the reading is going on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to run under an inconsistent transaction. Must have the signature type (<a class="el" href="class_w_s_t_m_1_1_w_inconsistent.html" title="Functions passed to Inconsistently must take a reference to one of these objects as their only argume...">WInconsistent</a>&amp;) where "type" can be void or any other type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of op.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="struct_w_s_t_m_1_1_w_in_atomic_error.html" title="Exception thrown by WNoAtomic if it is constructed within a transaction. ">WInAtomicError</a></td><td>if this function is called from a function running under an atomic transaction. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stm_8h_source.html#l00977">977</a> of file <a class="el" href="stm_8h_source.html">stm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac553425cfd41fcf60669313f91a162a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSTM_LIBAPI void WSTM::Retry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html">WAtomic</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_s_t_m_1_1_w_time_arg.html">WTimeArg</a> &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="struct_w_s_t_m_1_1_w_time_arg.html#a34264c61a82f2f25f87f8c9189157fab">WTimeArg::Unlimited</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a function passed to Atomically determines that one of the <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> objects's that it has read has a value that prevents the function from finishing then the function should call Retry. </p>
<p>When Retry is called the current transaction is abandoned and the thread is blocked until one of the <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> object's that was read is changed by another thread. When a change is detected the blocked thread will be resumed and the atomic operation will be restarted. Note that if there have been nested atomically calls then the outermost call will be the one restarted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>An optional timeout value. If the retry waits for this long then a <a class="el" href="struct_w_s_t_m_1_1_w_retry_timeout_exception.html" title="Exception thrown when a retry times out. ">WRetryTimeoutException</a> will be thrown out of the outermost atomically call. By default this function waits forever. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79f61cd02ad11aea2a826075c1f44500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func_t , typename... Options_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto WSTM::RunAtomically </td>
          <td>(</td>
          <td class="paramtype">const Func_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Options_t &amp;...&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a function object that runs the given function in a transaction with the given options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to carry out. This function must have signature "result f(WAtomic&amp;)" where result is either void or a copy constructable type.</td></tr>
    <tr><td class="paramname">options</td><td>Arguments that set various options, see <a class="el" href="group__atomically__options.html">here</a> for options that are recognized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function object that will run f in a transaction using the given options. </dd></dl>

<p>Definition at line <a class="el" href="stm_8h_source.html#l00901">901</a> of file <a class="el" href="stm_8h_source.html">stm.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
