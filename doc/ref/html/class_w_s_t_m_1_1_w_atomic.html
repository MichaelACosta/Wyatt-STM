<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Wyatt-STM: WSTM::WAtomic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wyatt-STM
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Software transactional memory system developed at Wyatt Technology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_w_s_t_m.html">WSTM</a></li><li class="navelem"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html">WAtomic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_w_s_t_m_1_1_w_atomic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WSTM::WAtomic Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions passed to Atomically must take a reference to one of these objects as their only argument.  
 <a href="class_w_s_t_m_1_1_w_atomic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stm_8h_source.html">stm.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1864df0db7ce8cfa34718d19b44f631d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1864df0db7ce8cfa34718d19b44f631d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a1864df0db7ce8cfa34718d19b44f631d">WBeforeCommitFunc</a> = std::function&lt; void(<a class="el" href="class_w_s_t_m_1_1_w_atomic.html">WAtomic</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a1864df0db7ce8cfa34718d19b44f631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of functions that can be passed to BeforeCommit. <br /></td></tr>
<tr class="separator:a1864df0db7ce8cfa34718d19b44f631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4566c901d1852ca3ad3a92ad493a8dac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4566c901d1852ca3ad3a92ad493a8dac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a4566c901d1852ca3ad3a92ad493a8dac">WAfterFunc</a> = std::function&lt; void(void)&gt;</td></tr>
<tr class="memdesc:a4566c901d1852ca3ad3a92ad493a8dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of functions that can be passed to After. <br /></td></tr>
<tr class="separator:a4566c901d1852ca3ad3a92ad493a8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9060684d0f8a063eaf44067f97623b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb9060684d0f8a063eaf44067f97623b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#acb9060684d0f8a063eaf44067f97623b">WOnFailFunc</a> = std::function&lt; void(void)&gt;</td></tr>
<tr class="memdesc:acb9060684d0f8a063eaf44067f97623b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of functions that can be passed to OnFail. <br /></td></tr>
<tr class="separator:acb9060684d0f8a063eaf44067f97623b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2aa9c1d17db22d051a5a1f5dc6938784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a2aa9c1d17db22d051a5a1f5dc6938784">Validate</a> () const </td></tr>
<tr class="memdesc:a2aa9c1d17db22d051a5a1f5dc6938784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the current transaction for memory consistency.  <a href="#a2aa9c1d17db22d051a5a1f5dc6938784">More...</a><br /></td></tr>
<tr class="separator:a2aa9c1d17db22d051a5a1f5dc6938784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8037cf1cff612bfd2c244ee57d2da3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a8037cf1cff612bfd2c244ee57d2da3e4">ReadLock</a> ()</td></tr>
<tr class="memdesc:a8037cf1cff612bfd2c244ee57d2da3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the transaction to acquire a read lock.  <a href="#a8037cf1cff612bfd2c244ee57d2da3e4">More...</a><br /></td></tr>
<tr class="separator:a8037cf1cff612bfd2c244ee57d2da3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9dd57bbd073af0bed993da4771a61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a69f9dd57bbd073af0bed993da4771a61">IsReadLocked</a> () const </td></tr>
<tr class="memdesc:a69f9dd57bbd073af0bed993da4771a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a read lock is held or not.  <a href="#a69f9dd57bbd073af0bed993da4771a61">More...</a><br /></td></tr>
<tr class="separator:a69f9dd57bbd073af0bed993da4771a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a41a852d05b5518da535b0e725718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a2d3a41a852d05b5518da535b0e725718">ReadUnlock</a> ()</td></tr>
<tr class="memdesc:a2d3a41a852d05b5518da535b0e725718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the read lock acquired by a call to readLock.  <a href="#a2d3a41a852d05b5518da535b0e725718">More...</a><br /></td></tr>
<tr class="separator:a2d3a41a852d05b5518da535b0e725718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7643458e9d8a9536f67dfcb4409baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#aec7643458e9d8a9536f67dfcb4409baa">BeforeCommit</a> (<a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a1864df0db7ce8cfa34718d19b44f631d">WBeforeCommitFunc</a> func)</td></tr>
<tr class="memdesc:aec7643458e9d8a9536f67dfcb4409baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to call just before the top-level transaction that is currently running starts to commit.  <a href="#aec7643458e9d8a9536f67dfcb4409baa">More...</a><br /></td></tr>
<tr class="separator:aec7643458e9d8a9536f67dfcb4409baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb66ce8f77e9f6fcfc3b3ddd1d25f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a0eb66ce8f77e9f6fcfc3b3ddd1d25f86">After</a> (<a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a4566c901d1852ca3ad3a92ad493a8dac">WAfterFunc</a> func)</td></tr>
<tr class="memdesc:a0eb66ce8f77e9f6fcfc3b3ddd1d25f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to call after the top-level transaction that is currently running commits successfully.  <a href="#a0eb66ce8f77e9f6fcfc3b3ddd1d25f86">More...</a><br /></td></tr>
<tr class="separator:a0eb66ce8f77e9f6fcfc3b3ddd1d25f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdbb4d00d707479b59194ff1ebabafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a5fdbb4d00d707479b59194ff1ebabafe">OnFail</a> (<a class="el" href="class_w_s_t_m_1_1_w_atomic.html#acb9060684d0f8a063eaf44067f97623b">WOnFailFunc</a> func)</td></tr>
<tr class="memdesc:a5fdbb4d00d707479b59194ff1ebabafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function that will be called if this transaction fails to commit for some reason (e.g.  <a href="#a5fdbb4d00d707479b59194ff1ebabafe">More...</a><br /></td></tr>
<tr class="separator:a5fdbb4d00d707479b59194ff1ebabafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50737cb5192b4def53a3a29b75cc1422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50737cb5192b4def53a3a29b75cc1422"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a50737cb5192b4def53a3a29b75cc1422">~WAtomic</a> ()</td></tr>
<tr class="memdesc:a50737cb5192b4def53a3a29b75cc1422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object. <br /></td></tr>
<tr class="separator:a50737cb5192b4def53a3a29b75cc1422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aedb0a937533655ccc37c5e2e680d2b0a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#aedb0a937533655ccc37c5e2e680d2b0a">AtomicallyImpl</a> (Internal::WAtomicOp &amp;op, const <a class="el" href="struct_w_s_t_m_1_1_w_max_conflicts.html">WMaxConflicts</a> &amp;maxConflicts, const <a class="el" href="struct_w_s_t_m_1_1_w_max_retries.html">WMaxRetries</a> &amp;maxRetries, const <a class="el" href="struct_w_s_t_m_1_1_w_max_retry_wait.html">WMaxRetryWait</a> &amp;maxRetryWait)</td></tr>
<tr class="memdesc:aedb0a937533655ccc37c5e2e680d2b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used internally, just ignore it.  <a href="#aedb0a937533655ccc37c5e2e680d2b0a">More...</a><br /></td></tr>
<tr class="separator:aedb0a937533655ccc37c5e2e680d2b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad177a1787fae715b86b6f2d9c7de227f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad177a1787fae715b86b6f2d9c7de227f"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:ad177a1787fae715b86b6f2d9c7de227f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WVar</b></td></tr>
<tr class="separator:ad177a1787fae715b86b6f2d9c7de227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e2ceba0d22dd42c800bda026f5f701"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3e2ceba0d22dd42c800bda026f5f701"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:ac3e2ceba0d22dd42c800bda026f5f701"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WTransactionLocalValue</b></td></tr>
<tr class="separator:ac3e2ceba0d22dd42c800bda026f5f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions passed to Atomically must take a reference to one of these objects as their only argument. </p>
<p>The public interface allows one to do transaction validation and register functions to be called when the transaction commits or fails. </p>

<p>Definition at line <a class="el" href="stm_8h_source.html#l00480">480</a> of file <a class="el" href="stm_8h_source.html">stm.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0eb66ce8f77e9f6fcfc3b3ddd1d25f86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::After </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a4566c901d1852ca3ad3a92ad493a8dac">WAfterFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to call after the top-level transaction that is currently running commits successfully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call after the top-level transaction commits. Be careful about what you do in these functions. The function will not run until the TOP-LEVEL transaction commits. This may be much later than you expect. Take steps to make sure that the data you think will be around when the function runs will still be around by using shared_ptr or something similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedb0a937533655ccc37c5e2e680d2b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void WSTM::WAtomic::AtomicallyImpl </td>
          <td>(</td>
          <td class="paramtype">Internal::WAtomicOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_s_t_m_1_1_w_max_conflicts.html">WMaxConflicts</a> &amp;&#160;</td>
          <td class="paramname"><em>maxConflicts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_s_t_m_1_1_w_max_retries.html">WMaxRetries</a> &amp;&#160;</td>
          <td class="paramname"><em>maxRetries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_s_t_m_1_1_w_max_retry_wait.html">WMaxRetryWait</a> &amp;&#160;</td>
          <td class="paramname"><em>maxRetryWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used internally, just ignore it. </p>
<p>You should be looking at Atomically instead. </p>

</div>
</div>
<a class="anchor" id="aec7643458e9d8a9536f67dfcb4409baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::BeforeCommit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#a1864df0db7ce8cfa34718d19b44f631d">WBeforeCommitFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to call just before the top-level transaction that is currently running starts to commit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call, it will be passed this transaction. Be careful about what you do in these functions. The function will not run until the TOP-LEVEL transaction commits. This may be much later than you expect. Take steps to make sure that the data you think will be around when the function runs will still be around by using shared_ptr or something similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69f9dd57bbd073af0bed993da4771a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WSTM::WAtomic::IsReadLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a read lock is held or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction is holding a read lock, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fdbb4d00d707479b59194ff1ebabafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::OnFail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_w_s_t_m_1_1_w_atomic.html#acb9060684d0f8a063eaf44067f97623b">WOnFailFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function that will be called if this transaction fails to commit for some reason (e.g. </p>
<p>there is a conflict, an exception is thrown or the transacation is retried). This is useful if you allocate resources that need to be cleaned up if the transaction fails to commit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8037cf1cff612bfd2c244ee57d2da3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::ReadLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the transaction to acquire a read lock. </p>
<p>Normally during the course of reading a <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> a read lock is acquired and released. This can be a performance problem when a lot of WVars need to be read. In those cases this method should be called so that one read lock will be held while doing the reads. The lock will be held until either readUnlock has been called an equal number of times as readLock or the transaction ends. Normally <a class="el" href="class_w_s_t_m_1_1_w_read_lock_guard.html" title="Read-lock manager for WAtomic and WInconsistent. ">WReadLockGuard</a> should be used instead of calling this directly. </p>

</div>
</div>
<a class="anchor" id="a2d3a41a852d05b5518da535b0e725718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::ReadUnlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the read lock acquired by a call to readLock. </p>
<p>This method must be called an equal number of times as readLock has been called in order for the lock to actually be released. Normally <a class="el" href="class_w_s_t_m_1_1_w_read_lock_guard.html" title="Read-lock manager for WAtomic and WInconsistent. ">WReadLockGuard</a> should be used instead of calling this directly. </p>

</div>
</div>
<a class="anchor" id="a2aa9c1d17db22d051a5a1f5dc6938784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WSTM::WAtomic::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the current transaction for memory consistency. </p>
<p>If any of the <a class="el" href="class_w_s_t_m_1_1_w_var.html" title="A transactional variable. ">WVar</a> objects's that have been read have been changed by another thread then the current transaction is aborted and restarted. It is not a requirement to call this, it is done automatically when the operation being run by Atomically completes. It should be called periodically by long-running operations in order to avoid doing extra work when a transaction is already invalid. It should also be called if you have read a set of variables that have an associated invariant and need that invariant to be enforced. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/Wyatt-STM/wstm/<a class="el" href="stm_8h_source.html">stm.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
